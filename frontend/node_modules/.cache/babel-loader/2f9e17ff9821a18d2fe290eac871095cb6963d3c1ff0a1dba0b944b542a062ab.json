{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { map } from '../operators/map';\nimport { Observable } from '../Observable';\nimport { AjaxResponse } from './AjaxResponse';\nimport { AjaxTimeoutError, AjaxError } from './errors';\nfunction ajaxGet(url, headers) {\n  return ajax({\n    method: 'GET',\n    url: url,\n    headers: headers\n  });\n}\nfunction ajaxPost(url, body, headers) {\n  return ajax({\n    method: 'POST',\n    url: url,\n    body: body,\n    headers: headers\n  });\n}\nfunction ajaxDelete(url, headers) {\n  return ajax({\n    method: 'DELETE',\n    url: url,\n    headers: headers\n  });\n}\nfunction ajaxPut(url, body, headers) {\n  return ajax({\n    method: 'PUT',\n    url: url,\n    body: body,\n    headers: headers\n  });\n}\nfunction ajaxPatch(url, body, headers) {\n  return ajax({\n    method: 'PATCH',\n    url: url,\n    body: body,\n    headers: headers\n  });\n}\nvar mapResponse = map(function (x) {\n  return x.response;\n});\nfunction ajaxGetJSON(url, headers) {\n  return mapResponse(ajax({\n    method: 'GET',\n    url: url,\n    headers: headers\n  }));\n}\nexport var ajax = function () {\n  var create = function (urlOrConfig) {\n    var config = typeof urlOrConfig === 'string' ? {\n      url: urlOrConfig\n    } : urlOrConfig;\n    return fromAjax(config);\n  };\n  create.get = ajaxGet;\n  create.post = ajaxPost;\n  create.delete = ajaxDelete;\n  create.put = ajaxPut;\n  create.patch = ajaxPatch;\n  create.getJSON = ajaxGetJSON;\n  return create;\n}();\nvar UPLOAD = 'upload';\nvar DOWNLOAD = 'download';\nvar LOADSTART = 'loadstart';\nvar PROGRESS = 'progress';\nvar LOAD = 'load';\nexport function fromAjax(init) {\n  return new Observable(function (destination) {\n    var _a, _b;\n    var config = __assign({\n      async: true,\n      crossDomain: false,\n      withCredentials: false,\n      method: 'GET',\n      timeout: 0,\n      responseType: 'json'\n    }, init);\n    var queryParams = config.queryParams,\n      configuredBody = config.body,\n      configuredHeaders = config.headers;\n    var url = config.url;\n    if (!url) {\n      throw new TypeError('url is required');\n    }\n    if (queryParams) {\n      var searchParams_1;\n      if (url.includes('?')) {\n        var parts = url.split('?');\n        if (2 < parts.length) {\n          throw new TypeError('invalid url');\n        }\n        searchParams_1 = new URLSearchParams(parts[1]);\n        new URLSearchParams(queryParams).forEach(function (value, key) {\n          return searchParams_1.set(key, value);\n        });\n        url = parts[0] + '?' + searchParams_1;\n      } else {\n        searchParams_1 = new URLSearchParams(queryParams);\n        url = url + '?' + searchParams_1;\n      }\n    }\n    var headers = {};\n    if (configuredHeaders) {\n      for (var key in configuredHeaders) {\n        if (configuredHeaders.hasOwnProperty(key)) {\n          headers[key.toLowerCase()] = configuredHeaders[key];\n        }\n      }\n    }\n    var crossDomain = config.crossDomain;\n    if (!crossDomain && !('x-requested-with' in headers)) {\n      headers['x-requested-with'] = 'XMLHttpRequest';\n    }\n    var withCredentials = config.withCredentials,\n      xsrfCookieName = config.xsrfCookieName,\n      xsrfHeaderName = config.xsrfHeaderName;\n    if ((withCredentials || !crossDomain) && xsrfCookieName && xsrfHeaderName) {\n      var xsrfCookie = (_b = (_a = document === null || document === void 0 ? void 0 : document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + xsrfCookieName + \")=([^;]*)\"))) === null || _a === void 0 ? void 0 : _a.pop()) !== null && _b !== void 0 ? _b : '';\n      if (xsrfCookie) {\n        headers[xsrfHeaderName] = xsrfCookie;\n      }\n    }\n    var body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);\n    var _request = __assign(__assign({}, config), {\n      url: url,\n      headers: headers,\n      body: body\n    });\n    var xhr;\n    xhr = init.createXHR ? init.createXHR() : new XMLHttpRequest();\n    {\n      var progressSubscriber_1 = init.progressSubscriber,\n        _c = init.includeDownloadProgress,\n        includeDownloadProgress = _c === void 0 ? false : _c,\n        _d = init.includeUploadProgress,\n        includeUploadProgress = _d === void 0 ? false : _d;\n      var addErrorEvent = function (type, errorFactory) {\n        xhr.addEventListener(type, function () {\n          var _a;\n          var error = errorFactory();\n          (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, error);\n          destination.error(error);\n        });\n      };\n      addErrorEvent('timeout', function () {\n        return new AjaxTimeoutError(xhr, _request);\n      });\n      addErrorEvent('abort', function () {\n        return new AjaxError('aborted', xhr, _request);\n      });\n      var createResponse_1 = function (direction, event) {\n        return new AjaxResponse(event, xhr, _request, direction + \"_\" + event.type);\n      };\n      var addProgressEvent_1 = function (target, type, direction) {\n        target.addEventListener(type, function (event) {\n          destination.next(createResponse_1(direction, event));\n        });\n      };\n      if (includeUploadProgress) {\n        [LOADSTART, PROGRESS, LOAD].forEach(function (type) {\n          return addProgressEvent_1(xhr.upload, type, UPLOAD);\n        });\n      }\n      if (progressSubscriber_1) {\n        [LOADSTART, PROGRESS].forEach(function (type) {\n          return xhr.upload.addEventListener(type, function (e) {\n            var _a;\n            return (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.next) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, e);\n          });\n        });\n      }\n      if (includeDownloadProgress) {\n        [LOADSTART, PROGRESS].forEach(function (type) {\n          return addProgressEvent_1(xhr, type, DOWNLOAD);\n        });\n      }\n      var emitError_1 = function (status) {\n        var msg = 'ajax error' + (status ? ' ' + status : '');\n        destination.error(new AjaxError(msg, xhr, _request));\n      };\n      xhr.addEventListener('error', function (e) {\n        var _a;\n        (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, e);\n        emitError_1();\n      });\n      xhr.addEventListener(LOAD, function (event) {\n        var _a, _b;\n        var status = xhr.status;\n        if (status < 400) {\n          (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.complete) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1);\n          var response = void 0;\n          try {\n            response = createResponse_1(DOWNLOAD, event);\n          } catch (err) {\n            destination.error(err);\n            return;\n          }\n          destination.next(response);\n          destination.complete();\n        } else {\n          (_b = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _b === void 0 ? void 0 : _b.call(progressSubscriber_1, event);\n          emitError_1(status);\n        }\n      });\n    }\n    var user = _request.user,\n      method = _request.method,\n      async = _request.async;\n    if (user) {\n      xhr.open(method, url, async, user, _request.password);\n    } else {\n      xhr.open(method, url, async);\n    }\n    if (async) {\n      xhr.timeout = _request.timeout;\n      xhr.responseType = _request.responseType;\n    }\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = _request.withCredentials;\n    }\n    for (var key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n    if (body) {\n      xhr.send(body);\n    } else {\n      xhr.send();\n    }\n    return function () {\n      if (xhr && xhr.readyState !== 4) {\n        xhr.abort();\n      }\n    };\n  });\n}\nfunction extractContentTypeAndMaybeSerializeBody(body, headers) {\n  var _a;\n  if (!body || typeof body === 'string' || isFormData(body) || isURLSearchParams(body) || isArrayBuffer(body) || isFile(body) || isBlob(body) || isReadableStream(body)) {\n    return body;\n  }\n  if (isArrayBufferView(body)) {\n    return body.buffer;\n  }\n  if (typeof body === 'object') {\n    headers['content-type'] = (_a = headers['content-type']) !== null && _a !== void 0 ? _a : 'application/json;charset=utf-8';\n    return JSON.stringify(body);\n  }\n  throw new TypeError('Unknown body type');\n}\nvar _toString = Object.prototype.toString;\nfunction toStringCheck(obj, name) {\n  return _toString.call(obj) === \"[object \" + name + \"]\";\n}\nfunction isArrayBuffer(body) {\n  return toStringCheck(body, 'ArrayBuffer');\n}\nfunction isFile(body) {\n  return toStringCheck(body, 'File');\n}\nfunction isBlob(body) {\n  return toStringCheck(body, 'Blob');\n}\nfunction isArrayBufferView(body) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(body);\n}\nfunction isFormData(body) {\n  return typeof FormData !== 'undefined' && body instanceof FormData;\n}\nfunction isURLSearchParams(body) {\n  return typeof URLSearchParams !== 'undefined' && body instanceof URLSearchParams;\n}\nfunction isReadableStream(body) {\n  return typeof ReadableStream !== 'undefined' && body instanceof ReadableStream;\n}","map":{"version":3,"names":["map","Observable","AjaxResponse","AjaxTimeoutError","AjaxError","ajaxGet","url","headers","ajax","method","ajaxPost","body","ajaxDelete","ajaxPut","ajaxPatch","mapResponse","x","response","ajaxGetJSON","create","urlOrConfig","config","fromAjax","get","post","delete","put","patch","getJSON","UPLOAD","DOWNLOAD","LOADSTART","PROGRESS","LOAD","init","destination","__assign","async","crossDomain","withCredentials","timeout","responseType","queryParams","configuredBody","configuredHeaders","TypeError","searchParams_1","includes","parts","split","length","URLSearchParams","forEach","value","key","set","hasOwnProperty","toLowerCase","xsrfCookieName","xsrfHeaderName","xsrfCookie","_b","_a","document","cookie","match","RegExp","pop","extractContentTypeAndMaybeSerializeBody","_request","xhr","createXHR","XMLHttpRequest","progressSubscriber_1","progressSubscriber","_c","includeDownloadProgress","_d","includeUploadProgress","addErrorEvent","type","errorFactory","addEventListener","error","call","createResponse_1","direction","event","addProgressEvent_1","target","next","upload","e","emitError_1","status","msg","complete","err","user","open","password","setRequestHeader","send","readyState","abort","isFormData","isURLSearchParams","isArrayBuffer","isFile","isBlob","isReadableStream","isArrayBufferView","buffer","JSON","stringify","_toString","Object","prototype","toString","toStringCheck","obj","name","ArrayBuffer","isView","FormData","ReadableStream"],"sources":["C:\\wamp64\\www\\alsia\\node_modules\\rxjs\\src\\internal\\ajax\\ajax.ts"],"sourcesContent":["import { map } from '../operators/map';\nimport { Observable } from '../Observable';\nimport { AjaxConfig, AjaxRequest, AjaxDirection, ProgressEventType } from './types';\nimport { AjaxResponse } from './AjaxResponse';\nimport { AjaxTimeoutError, AjaxError } from './errors';\n\nexport interface AjaxCreationMethod {\n  /**\n   * Creates an observable that will perform an AJAX request using the\n   * [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) in\n   * global scope by default.\n   *\n   * This is the most configurable option, and the basis for all other AJAX calls in the library.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { ajax } from 'rxjs/ajax';\n   * import { map, catchError, of } from 'rxjs';\n   *\n   * const obs$ = ajax({\n   *   method: 'GET',\n   *   url: 'https://api.github.com/users?per_page=5',\n   *   responseType: 'json'\n   * }).pipe(\n   *   map(userResponse => console.log('users: ', userResponse)),\n   *   catchError(error => {\n   *     console.log('error: ', error);\n   *     return of(error);\n   *   })\n   * );\n   * ```\n   */\n  <T>(config: AjaxConfig): Observable<AjaxResponse<T>>;\n\n  /**\n   * Perform an HTTP GET using the\n   * [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) in\n   * global scope. Defaults to a `responseType` of `\"json\"`.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { ajax } from 'rxjs/ajax';\n   * import { map, catchError, of } from 'rxjs';\n   *\n   * const obs$ = ajax('https://api.github.com/users?per_page=5').pipe(\n   *   map(userResponse => console.log('users: ', userResponse)),\n   *   catchError(error => {\n   *     console.log('error: ', error);\n   *     return of(error);\n   *   })\n   * );\n   * ```\n   */\n  <T>(url: string): Observable<AjaxResponse<T>>;\n\n  /**\n   * Performs an HTTP GET using the\n   * [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) in\n   * global scope by default, and a `responseType` of `\"json\"`.\n   *\n   * @param url The URL to get the resource from\n   * @param headers Optional headers. Case-Insensitive.\n   */\n  get<T>(url: string, headers?: Record<string, string>): Observable<AjaxResponse<T>>;\n\n  /**\n   * Performs an HTTP POST using the\n   * [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) in\n   * global scope by default, and a `responseType` of `\"json\"`.\n   *\n   * Before sending the value passed to the `body` argument, it is automatically serialized\n   * based on the specified `responseType`. By default, a JavaScript object will be serialized\n   * to JSON. A `responseType` of `application/x-www-form-urlencoded` will flatten any provided\n   * dictionary object to a url-encoded string.\n   *\n   * @param url The URL to get the resource from\n   * @param body The content to send. The body is automatically serialized.\n   * @param headers Optional headers. Case-Insensitive.\n   */\n  post<T>(url: string, body?: any, headers?: Record<string, string>): Observable<AjaxResponse<T>>;\n\n  /**\n   * Performs an HTTP PUT using the\n   * [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) in\n   * global scope by default, and a `responseType` of `\"json\"`.\n   *\n   * Before sending the value passed to the `body` argument, it is automatically serialized\n   * based on the specified `responseType`. By default, a JavaScript object will be serialized\n   * to JSON. A `responseType` of `application/x-www-form-urlencoded` will flatten any provided\n   * dictionary object to a url-encoded string.\n   *\n   * @param url The URL to get the resource from\n   * @param body The content to send. The body is automatically serialized.\n   * @param headers Optional headers. Case-Insensitive.\n   */\n  put<T>(url: string, body?: any, headers?: Record<string, string>): Observable<AjaxResponse<T>>;\n\n  /**\n   * Performs an HTTP PATCH using the\n   * [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) in\n   * global scope by default, and a `responseType` of `\"json\"`.\n   *\n   * Before sending the value passed to the `body` argument, it is automatically serialized\n   * based on the specified `responseType`. By default, a JavaScript object will be serialized\n   * to JSON. A `responseType` of `application/x-www-form-urlencoded` will flatten any provided\n   * dictionary object to a url-encoded string.\n   *\n   * @param url The URL to get the resource from\n   * @param body The content to send. The body is automatically serialized.\n   * @param headers Optional headers. Case-Insensitive.\n   */\n  patch<T>(url: string, body?: any, headers?: Record<string, string>): Observable<AjaxResponse<T>>;\n\n  /**\n   * Performs an HTTP DELETE using the\n   * [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) in\n   * global scope by default, and a `responseType` of `\"json\"`.\n   *\n   * @param url The URL to get the resource from\n   * @param headers Optional headers. Case-Insensitive.\n   */\n  delete<T>(url: string, headers?: Record<string, string>): Observable<AjaxResponse<T>>;\n\n  /**\n   * Performs an HTTP GET using the\n   * [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) in\n   * global scope by default, and returns the hydrated JavaScript object from the\n   * response.\n   *\n   * @param url The URL to get the resource from\n   * @param headers Optional headers. Case-Insensitive.\n   */\n  getJSON<T>(url: string, headers?: Record<string, string>): Observable<T>;\n}\n\nfunction ajaxGet<T>(url: string, headers?: Record<string, string>): Observable<AjaxResponse<T>> {\n  return ajax({ method: 'GET', url, headers });\n}\n\nfunction ajaxPost<T>(url: string, body?: any, headers?: Record<string, string>): Observable<AjaxResponse<T>> {\n  return ajax({ method: 'POST', url, body, headers });\n}\n\nfunction ajaxDelete<T>(url: string, headers?: Record<string, string>): Observable<AjaxResponse<T>> {\n  return ajax({ method: 'DELETE', url, headers });\n}\n\nfunction ajaxPut<T>(url: string, body?: any, headers?: Record<string, string>): Observable<AjaxResponse<T>> {\n  return ajax({ method: 'PUT', url, body, headers });\n}\n\nfunction ajaxPatch<T>(url: string, body?: any, headers?: Record<string, string>): Observable<AjaxResponse<T>> {\n  return ajax({ method: 'PATCH', url, body, headers });\n}\n\nconst mapResponse = map((x: AjaxResponse<any>) => x.response);\n\nfunction ajaxGetJSON<T>(url: string, headers?: Record<string, string>): Observable<T> {\n  return mapResponse(\n    ajax<T>({\n      method: 'GET',\n      url,\n      headers,\n    })\n  );\n}\n\n/**\n * There is an ajax operator on the Rx object.\n *\n * It creates an observable for an Ajax request with either a request object with\n * url, headers, etc or a string for a URL.\n *\n * ## Examples\n *\n * Using `ajax()` to fetch the response object that is being returned from API\n *\n * ```ts\n * import { ajax } from 'rxjs/ajax';\n * import { map, catchError, of } from 'rxjs';\n *\n * const obs$ = ajax('https://api.github.com/users?per_page=5').pipe(\n *   map(userResponse => console.log('users: ', userResponse)),\n *   catchError(error => {\n *     console.log('error: ', error);\n *     return of(error);\n *   })\n * );\n *\n * obs$.subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(err)\n * });\n * ```\n *\n * Using `ajax.getJSON()` to fetch data from API\n *\n * ```ts\n * import { ajax } from 'rxjs/ajax';\n * import { map, catchError, of } from 'rxjs';\n *\n * const obs$ = ajax.getJSON('https://api.github.com/users?per_page=5').pipe(\n *   map(userResponse => console.log('users: ', userResponse)),\n *   catchError(error => {\n *     console.log('error: ', error);\n *     return of(error);\n *   })\n * );\n *\n * obs$.subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(err)\n * });\n * ```\n *\n * Using `ajax()` with object as argument and method POST with a two seconds delay\n *\n * ```ts\n * import { ajax } from 'rxjs/ajax';\n * import { map, catchError, of } from 'rxjs';\n *\n * const users = ajax({\n *   url: 'https://httpbin.org/delay/2',\n *   method: 'POST',\n *   headers: {\n *     'Content-Type': 'application/json',\n *     'rxjs-custom-header': 'Rxjs'\n *   },\n *   body: {\n *     rxjs: 'Hello World!'\n *   }\n * }).pipe(\n *   map(response => console.log('response: ', response)),\n *   catchError(error => {\n *     console.log('error: ', error);\n *     return of(error);\n *   })\n * );\n *\n * users.subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(err)\n * });\n * ```\n *\n * Using `ajax()` to fetch. An error object that is being returned from the request\n *\n * ```ts\n * import { ajax } from 'rxjs/ajax';\n * import { map, catchError, of } from 'rxjs';\n *\n * const obs$ = ajax('https://api.github.com/404').pipe(\n *   map(userResponse => console.log('users: ', userResponse)),\n *   catchError(error => {\n *     console.log('error: ', error);\n *     return of(error);\n *   })\n * );\n *\n * obs$.subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(err)\n * });\n * ```\n */\nexport const ajax: AjaxCreationMethod = (() => {\n  const create = <T>(urlOrConfig: string | AjaxConfig) => {\n    const config: AjaxConfig =\n      typeof urlOrConfig === 'string'\n        ? {\n            url: urlOrConfig,\n          }\n        : urlOrConfig;\n    return fromAjax<T>(config);\n  };\n\n  create.get = ajaxGet;\n  create.post = ajaxPost;\n  create.delete = ajaxDelete;\n  create.put = ajaxPut;\n  create.patch = ajaxPatch;\n  create.getJSON = ajaxGetJSON;\n\n  return create;\n})();\n\nconst UPLOAD = 'upload';\nconst DOWNLOAD = 'download';\nconst LOADSTART = 'loadstart';\nconst PROGRESS = 'progress';\nconst LOAD = 'load';\n\nexport function fromAjax<T>(init: AjaxConfig): Observable<AjaxResponse<T>> {\n  return new Observable((destination) => {\n    const config = {\n      // Defaults\n      async: true,\n      crossDomain: false,\n      withCredentials: false,\n      method: 'GET',\n      timeout: 0,\n      responseType: 'json' as XMLHttpRequestResponseType,\n\n      ...init,\n    };\n\n    const { queryParams, body: configuredBody, headers: configuredHeaders } = config;\n\n    let url = config.url;\n    if (!url) {\n      throw new TypeError('url is required');\n    }\n\n    if (queryParams) {\n      let searchParams: URLSearchParams;\n      if (url.includes('?')) {\n        // If the user has passed a URL with a querystring already in it,\n        // we need to combine them. So we're going to split it. There\n        // should only be one `?` in a valid URL.\n        const parts = url.split('?');\n        if (2 < parts.length) {\n          throw new TypeError('invalid url');\n        }\n        // Add the passed queryParams to the params already in the url provided.\n        searchParams = new URLSearchParams(parts[1]);\n        // queryParams is converted to any because the runtime is *much* more permissive than\n        // the types are.\n        new URLSearchParams(queryParams as any).forEach((value, key) => searchParams.set(key, value));\n        // We have to do string concatenation here, because `new URL(url)` does\n        // not like relative URLs like `/this` without a base url, which we can't\n        // specify, nor can we assume `location` will exist, because of node.\n        url = parts[0] + '?' + searchParams;\n      } else {\n        // There is no preexisting querystring, so we can just use URLSearchParams\n        // to convert the passed queryParams into the proper format and encodings.\n        // queryParams is converted to any because the runtime is *much* more permissive than\n        // the types are.\n        searchParams = new URLSearchParams(queryParams as any);\n        url = url + '?' + searchParams;\n      }\n    }\n\n    // Normalize the headers. We're going to make them all lowercase, since\n    // Headers are case insensitive by design. This makes it easier to verify\n    // that we aren't setting or sending duplicates.\n    const headers: Record<string, any> = {};\n    if (configuredHeaders) {\n      for (const key in configuredHeaders) {\n        if (configuredHeaders.hasOwnProperty(key)) {\n          headers[key.toLowerCase()] = configuredHeaders[key];\n        }\n      }\n    }\n\n    const crossDomain = config.crossDomain;\n\n    // Set the x-requested-with header. This is a non-standard header that has\n    // come to be a de facto standard for HTTP requests sent by libraries and frameworks\n    // using XHR. However, we DO NOT want to set this if it is a CORS request. This is\n    // because sometimes this header can cause issues with CORS. To be clear,\n    // None of this is necessary, it's only being set because it's \"the thing libraries do\"\n    // Starting back as far as JQuery, and continuing with other libraries such as Angular 1,\n    // Axios, et al.\n    if (!crossDomain && !('x-requested-with' in headers)) {\n      headers['x-requested-with'] = 'XMLHttpRequest';\n    }\n\n    // Allow users to provide their XSRF cookie name and the name of a custom header to use to\n    // send the cookie.\n    const { withCredentials, xsrfCookieName, xsrfHeaderName } = config;\n    if ((withCredentials || !crossDomain) && xsrfCookieName && xsrfHeaderName) {\n      const xsrfCookie = document?.cookie.match(new RegExp(`(^|;\\\\s*)(${xsrfCookieName})=([^;]*)`))?.pop() ?? '';\n      if (xsrfCookie) {\n        headers[xsrfHeaderName] = xsrfCookie;\n      }\n    }\n\n    // Examine the body and determine whether or not to serialize it\n    // and set the content-type in `headers`, if we're able.\n    const body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);\n\n    // The final request settings.\n    const _request: Readonly<AjaxRequest> = {\n      ...config,\n\n      // Set values we ensured above\n      url,\n      headers,\n      body,\n    };\n\n    let xhr: XMLHttpRequest;\n\n    // Create our XHR so we can get started.\n    xhr = init.createXHR ? init.createXHR() : new XMLHttpRequest();\n\n    {\n      ///////////////////////////////////////////////////\n      // set up the events before open XHR\n      // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n      // You need to add the event listeners before calling open() on the request.\n      // Otherwise the progress events will not fire.\n      ///////////////////////////////////////////////////\n\n      const { progressSubscriber, includeDownloadProgress = false, includeUploadProgress = false } = init;\n\n      /**\n       * Wires up an event handler that will emit an error when fired. Used\n       * for timeout and abort events.\n       * @param type The type of event we're treating as an error\n       * @param errorFactory A function that creates the type of error to emit.\n       */\n      const addErrorEvent = (type: string, errorFactory: () => any) => {\n        xhr.addEventListener(type, () => {\n          const error = errorFactory();\n          progressSubscriber?.error?.(error);\n          destination.error(error);\n        });\n      };\n\n      // If the request times out, handle errors appropriately.\n      addErrorEvent('timeout', () => new AjaxTimeoutError(xhr, _request));\n\n      // If the request aborts (due to a network disconnection or the like), handle\n      // it as an error.\n      addErrorEvent('abort', () => new AjaxError('aborted', xhr, _request));\n\n      /**\n       * Creates a response object to emit to the consumer.\n       * @param direction the direction related to the event. Prefixes the event `type` in the\n       * `AjaxResponse` object with \"upload_\" for events related to uploading and \"download_\"\n       * for events related to downloading.\n       * @param event the actual event object.\n       */\n      const createResponse = (direction: AjaxDirection, event: ProgressEvent) =>\n        new AjaxResponse<T>(event, xhr, _request, `${direction}_${event.type as ProgressEventType}` as const);\n\n      /**\n       * Wires up an event handler that emits a Response object to the consumer, used for\n       * all events that emit responses, loadstart, progress, and load.\n       * Note that download load handling is a bit different below, because it has\n       * more logic it needs to run.\n       * @param target The target, either the XHR itself or the Upload object.\n       * @param type The type of event to wire up\n       * @param direction The \"direction\", used to prefix the response object that is\n       * emitted to the consumer. (e.g. \"upload_\" or \"download_\")\n       */\n      const addProgressEvent = (target: any, type: string, direction: AjaxDirection) => {\n        target.addEventListener(type, (event: ProgressEvent) => {\n          destination.next(createResponse(direction, event));\n        });\n      };\n\n      if (includeUploadProgress) {\n        [LOADSTART, PROGRESS, LOAD].forEach((type) => addProgressEvent(xhr.upload, type, UPLOAD));\n      }\n\n      if (progressSubscriber) {\n        [LOADSTART, PROGRESS].forEach((type) => xhr.upload.addEventListener(type, (e: any) => progressSubscriber?.next?.(e)));\n      }\n\n      if (includeDownloadProgress) {\n        [LOADSTART, PROGRESS].forEach((type) => addProgressEvent(xhr, type, DOWNLOAD));\n      }\n\n      const emitError = (status?: number) => {\n        const msg = 'ajax error' + (status ? ' ' + status : '');\n        destination.error(new AjaxError(msg, xhr, _request));\n      };\n\n      xhr.addEventListener('error', (e) => {\n        progressSubscriber?.error?.(e);\n        emitError();\n      });\n\n      xhr.addEventListener(LOAD, (event) => {\n        const { status } = xhr;\n        // 4xx and 5xx should error (https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)\n        if (status < 400) {\n          progressSubscriber?.complete?.();\n\n          let response: AjaxResponse<T>;\n          try {\n            // This can throw in IE, because we end up needing to do a JSON.parse\n            // of the response in some cases to produce object we'd expect from\n            // modern browsers.\n            response = createResponse(DOWNLOAD, event);\n          } catch (err) {\n            destination.error(err);\n            return;\n          }\n\n          destination.next(response);\n          destination.complete();\n        } else {\n          progressSubscriber?.error?.(event);\n          emitError(status);\n        }\n      });\n    }\n\n    const { user, method, async } = _request;\n    // open XHR\n    if (user) {\n      xhr.open(method, url, async, user, _request.password);\n    } else {\n      xhr.open(method, url, async);\n    }\n\n    // timeout, responseType and withCredentials can be set once the XHR is open\n    if (async) {\n      xhr.timeout = _request.timeout;\n      xhr.responseType = _request.responseType;\n    }\n\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = _request.withCredentials;\n    }\n\n    // set headers\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n\n    // finally send the request\n    if (body) {\n      xhr.send(body);\n    } else {\n      xhr.send();\n    }\n\n    return () => {\n      if (xhr && xhr.readyState !== 4 /*XHR done*/) {\n        xhr.abort();\n      }\n    };\n  });\n}\n\n/**\n * Examines the body to determine if we need to serialize it for them or not.\n * If the body is a type that XHR handles natively, we just allow it through,\n * otherwise, if the body is something that *we* can serialize for the user,\n * we will serialize it, and attempt to set the `content-type` header, if it's\n * not already set.\n * @param body The body passed in by the user\n * @param headers The normalized headers\n */\nfunction extractContentTypeAndMaybeSerializeBody(body: any, headers: Record<string, string>) {\n  if (\n    !body ||\n    typeof body === 'string' ||\n    isFormData(body) ||\n    isURLSearchParams(body) ||\n    isArrayBuffer(body) ||\n    isFile(body) ||\n    isBlob(body) ||\n    isReadableStream(body)\n  ) {\n    // The XHR instance itself can handle serializing these, and set the content-type for us\n    // so we don't need to do that. https://xhr.spec.whatwg.org/#the-send()-method\n    return body;\n  }\n\n  if (isArrayBufferView(body)) {\n    // This is a typed array (e.g. Float32Array or Uint8Array), or a DataView.\n    // XHR can handle this one too: https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n    return body.buffer;\n  }\n\n  if (typeof body === 'object') {\n    // If we have made it here, this is an object, probably a POJO, and we'll try\n    // to serialize it for them. If this doesn't work, it will throw, obviously, which\n    // is okay. The workaround for users would be to manually set the body to their own\n    // serialized string (accounting for circular references or whatever), then set\n    // the content-type manually as well.\n    headers['content-type'] = headers['content-type'] ?? 'application/json;charset=utf-8';\n    return JSON.stringify(body);\n  }\n\n  // If we've gotten past everything above, this is something we don't quite know how to\n  // handle. Throw an error. This will be caught and emitted from the observable.\n  throw new TypeError('Unknown body type');\n}\n\nconst _toString = Object.prototype.toString;\n\nfunction toStringCheck(obj: any, name: string): boolean {\n  return _toString.call(obj) === `[object ${name}]`;\n}\n\nfunction isArrayBuffer(body: any): body is ArrayBuffer {\n  return toStringCheck(body, 'ArrayBuffer');\n}\n\nfunction isFile(body: any): body is File {\n  return toStringCheck(body, 'File');\n}\n\nfunction isBlob(body: any): body is Blob {\n  return toStringCheck(body, 'Blob');\n}\n\nfunction isArrayBufferView(body: any): body is ArrayBufferView {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(body);\n}\n\nfunction isFormData(body: any): body is FormData {\n  return typeof FormData !== 'undefined' && body instanceof FormData;\n}\n\nfunction isURLSearchParams(body: any): body is URLSearchParams {\n  return typeof URLSearchParams !== 'undefined' && body instanceof URLSearchParams;\n}\n\nfunction isReadableStream(body: any): body is ReadableStream {\n  return typeof ReadableStream !== 'undefined' && body instanceof ReadableStream;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}